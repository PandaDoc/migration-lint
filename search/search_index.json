{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to migration-lint","text":"<p><code>migration-lint</code> is the modular linter tool designed to perform checks on database schema migrations and prevent unsafe operations.</p> <p>Features:</p> <ul> <li>Works with Django migrations,   Alembic and raw sql files.</li> <li>Easily extensible for other frameworks.</li> <li>Can identify Backward Incompatible operations   and check if they are allowed in the current context.</li> <li>Can identify \"unsafe\" operations, e.g. operations that acquire locks   that can be dangerous for production database.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>poetry add \"migration-lint\"\n</code></pre> <pre><code>pip install \"migration-lint\"\n</code></pre>"},{"location":"#terms","title":"Terms","text":"<ul> <li>Source loader (or just loader) - class that loads list of changed files.</li> <li>Extractor - class that extracts SQL by migration name,   so it depends on the framework you use for migrations.</li> <li>Linter - class that checks migration's SQL and context   and returns errors if any. We have implemented our linter   for backward incompatible migrations as well as integrated <code>squawk</code> linter.</li> </ul>"},{"location":"#run","title":"Run","text":""},{"location":"#local","title":"Local","text":"<p>If you need to check local git changes (for example before commit):</p> <pre><code>migration-lint --loader=local_git --extractor=&lt;your extractor&gt;\n</code></pre> <p>It will examine files in current repository that are added or modified and not yet commited.</p>"},{"location":"#gitlab","title":"GitLab","text":"<p>If you need to run it on the GitLab pipeline:</p> <pre><code>migration-lint --loader=gitlab_branch --extractor=&lt;your extractor&gt;\n</code></pre> <p>It relies on default GitLab environment variables, namely CI_PROJECT_ID, CI_COMMIT_BRANCH. You also should issue a token with read permissions and put it into env variable CI_DEPLOY_GITLAB_TOKEN.</p> <p>Also, these parameters can be passed via options:</p> <pre><code>migration-lint --loader=gitlab_branch --extractor=&lt;your extractor&gt;\n--project-id=&lt;proj id&gt; --branch=&lt;branch&gt; --gitlab-api-key=&lt;key&gt;\n</code></pre> <p>Also, version for Merge Requests is available:</p> <pre><code>migration-lint --loader=gitlab_branch --extractor=&lt;your extractor&gt;\n</code></pre> <p>I uses env variable CI_MERGE_REQUEST_ID or option --mr-id.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>We value feedback and are committed to supporting engineers throughout their journey.</p> <p>We have a dedicated email where we encourage engineers to share their feedback, ask questions, and seek assistance with any issues they may encounter. We appreciate your input and look forward to engaging with you to make your experience even better.</p> <p> Write us!</p>"},{"location":"classification/","title":"DB migrations classification","text":""},{"location":"classification/#context","title":"Context","text":"<p>This DB migration classification is intended to be a basis for the unified DB migrations process.</p>"},{"location":"classification/#migrations-classification","title":"Migrations Classification","text":""},{"location":"classification/#common-multi-stage-migrations-pattern","title":"Common Multi-Stage Migrations Pattern","text":"<p>All stages are optional.</p> Name Description Autorun? stage1 Backward-compatible schema migration + (optional) code migration safe stage2 Backfilling data migration * not safe on prod, safe on stagings stage3 Code update that is a preparation for backward-incompatible schema migration stage4 Backward-incompatible schema migration * no on prod <p>According to this pattern, we distinguish the following types of migrations:</p> Name Stages Data migration * stage2 Backward-compatible migration * stage1 Backward-incompatible migration * stage3, stage4 Backward-incompatible migration requiring data backfilling * stage1, stage2, stage3 (optional), stage4"},{"location":"classification/#consequences","title":"Consequences","text":"<ul> <li>Backward-compatible schema changes can be combined with the corresponding code   updates (including the code required for backfilling data migrations).</li> <li>Code updates required to prepare for backward-incompatible changes   must be a separate deployment.</li> <li>Backward-incompatible schema changes must be a separate deployment.</li> </ul>"},{"location":"classification/#locks","title":"Locks","text":"Name Allowed DQL/DMS Commands Conflicting DQL/DML Commands AccessExclusiveLock SELECT, INSERT, UPDATE, DELETE ShareRowExclusiveLock SELECT INSERT, UPDATE, DELETE"},{"location":"classification/#migrations","title":"Migrations","text":""},{"location":"classification/#notes","title":"Notes","text":"<ul> <li>We try to make all migrations idempotent.</li> <li>We note locks if they are important.</li> </ul>"},{"location":"classification/#index-operations","title":"Index Operations","text":""},{"location":"classification/#create-index","title":"Create Index","text":"<p>Backward-compatible migration</p> <ul> <li>stage1 <code>CREATE INDEX CONCURRENTLY IF NOT EXISTS ....</code> <code>REINDEX INDEX CONCURRENTLY &lt;index_name&gt;</code> (if not valid)   *Update code to use the new index (optional, if the index is used in code).</li> </ul>"},{"location":"classification/#drop-index","title":"Drop Index","text":"<p>Backward-incompatible migration</p> <ul> <li>stage3: Update code to not use an index that will be deleted (optional,   if the index is used in code).</li> <li>stage4: <code>DROP INDEX CONCURRENTLY IF EXISTS &lt;indexname&gt;</code>.</li> </ul> <p>Note: <code>DROP INDEX CONCURRENTLY</code> cannot be used to drop any index that supports a constraint. See Drop primary key and Drop UNIQUE constraint.</p>"},{"location":"classification/#rename-index","title":"Rename Index","text":"<p>Backward-compatible migration</p> <ul> <li>stage1: <code>ALTER INDEX IF EXISTS ... RENAME TO ....</code></li> </ul>"},{"location":"classification/#reindex","title":"Reindex","text":"<p>Backward-compatible migration</p> <ul> <li>stage1: <code>REINDEX INDEX CONCURRENTLY ....</code></li> </ul>"},{"location":"classification/#sequence-operations","title":"Sequence Operations","text":""},{"location":"classification/#create-sequence","title":"Create Sequence","text":"<p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>CREATE SEQUENCE &lt;seqname&gt; ....</code></li> <li>Update code to use the new sequence   (optional, if the sequence is used in code).</li> </ul>"},{"location":"classification/#drop-sequence","title":"Drop Sequence","text":"<p>Backward-incompatible migration</p> <ul> <li>stage3: Update code to not use a sequence that will be deleted   (optional, if the sequence is used in code).</li> <li>stage4: <code>DROP SEQUENCE &lt;seqname&gt;</code>.</li> </ul>"},{"location":"classification/#alter-sequence","title":"Alter Sequence","text":"<p>Backward-compatible migration</p> <ul> <li>stage1: <code>ALTER SEQUENCE &lt;seqname&gt; ....</code></li> </ul>"},{"location":"classification/#table-operations","title":"Table Operations","text":""},{"location":"classification/#create-table","title":"Create Table","text":"<p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>CREATE TABLE &lt;tablename&gt; ...</code></li> <li>Update code to use the new table.</li> </ul> <p>WARNING: If there are foreign keys, table creation requires <code>ShareRowExclusiveLock</code> on the child tables, so use <code>lock_timeout</code> if the table to create contains foreign keys. <code>ADD FOREIGN KEY ... NOT VALID</code> does require the same lock, so it doesn\u2019t make much sense to create foreign keys separately.</p>"},{"location":"classification/#drop-table","title":"Drop Table","text":"<p>Backward-incompatible migration</p> <ul> <li>stage3: Update code to not use a table that will be deleted.</li> <li>stage4:</li> <li>Drop all foreign key constraints to the table (see Drop foreign key).</li> <li><code>DROP TABLE &lt;tablename&gt;</code>.</li> </ul>"},{"location":"classification/#rename-table","title":"Rename Table","text":"<p>Backward-incompatible migration</p> <ul> <li>stage1</li> <li>Rename a table and create a view for backward compatibility     (<code>AccessExclusiveLock</code>).</li> <li>Update code to use the new table name.</li> </ul> <pre><code>BEGIN;\nALTER TABLE &lt;tablename&gt; RENAME TO &lt;new_tablename&gt;;\nCREATE VIEW &lt;tablename&gt; AS\n  SELECT * FROM &lt;new_tablename&gt;;\nCOMMIT;\n</code></pre> <ul> <li>stage4: <code>DROP VIEW &lt;tablename&gt;</code></li> </ul>"},{"location":"classification/#column-operations","title":"Column Operations","text":""},{"location":"classification/#add-column-null","title":"ADD COLUMN ... NULL","text":"<p>Backward-compatible migration</p> <ul> <li>stage1</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; ... NULL</code></li> <li>Update code to use the new column.</li> </ul>"},{"location":"classification/#add-column-not-null","title":"ADD COLUMN ... NOT NULL","text":"<p>Backward-incompatible migration requiring data backfilling</p> <ul> <li>stage1</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; ... DEFAULT &lt;value&gt;</code>     (safe from PostgreSQL 11)</li> <li>Update code to use the new column (the code shouldn\u2019t create null values     for this column)</li> <li>stage2: Backfill the new column with the default value.   For existing table with data in it default value is mandatory.</li> <li>stage4: Add NOT NULL constraint:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code> (from PostgreSQL 12, \u201cif a valid CHECK constraint is found which proves   no NULL can exist, then the table scan is skipped\u201d).</li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP DEFAULT</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;</code>.</li> </ul>"},{"location":"classification/#alter-column-set-not-null","title":"ALTER COLUMN ... SET NOT NULL","text":"<p>Backward-incompatible migration requiring data backfilling</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt;     SET DEFAULT &lt;default_value&gt;.</code></li> <li>Update code to not write null values for the column.</li> <li>stage2: Backfill the column with the default value.</li> <li>stage4: Add NOT NULL constraint:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code> (from PostgreSQL 12, \u201cif a valid CHECK constraint is found   which proves no NULL can exist, then the table scan is skipped\u201d).</li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP DEFAULT.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;.</code></li> </ul>"},{"location":"classification/#alter-column-drop-not-null","title":"ALTER COLUMN ... DROP NOT NULL","text":"<p>Backward-compatible migration</p> <ul> <li>stage1: <code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP NOT NULL.</code></li> </ul>"},{"location":"classification/#add-column-null-default","title":"ADD COLUMN ... NULL DEFAULT  <p>Backward-compatible migration (safe from PostgreSQL 11)</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; ... NULL DEFAULT &lt;value&gt;.</code></li> <li>Update code to use the new column.</li> </ul>","text":""},{"location":"classification/#add-column-not-null-default","title":"ADD COLUMN ... NOT NULL DEFAULT  <p>Backward-compatible migration (safe from PostgreSQL 11)</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; ... NOT NULL DEFAULT &lt;value&gt;</code></li> <li>Update code to use the new column.</li> </ul>","text":""},{"location":"classification/#alter-column-set-default","title":"ALTER COLUMN ... SET DEFAULT <p>Backward-compatible migration</p> <ul> <li>stage1: <code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt;   SET DEFAULT &lt;default_value&gt;.</code></li> </ul>","text":""},{"location":"classification/#alter-column-drop-default","title":"ALTER COLUMN ... DROP DEFAULT <p>Backward-incompatible migration (in the worst case if the column is NOT NULL)</p> <ul> <li>stage3: Update the code to provide the default value   (optional, if the column is NOT NULL).</li> <li>stage4: <code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP DEFAULT.</code></li> </ul>","text":""},{"location":"classification/#add-column-bigserial-primary-key","title":"ADD COLUMN ... bigserial PRIMARY KEY <p>This is specific case for migrating tables ids from usual int to bigint.</p> <p>Backward-incompatible migration requiring data backfilling</p> <ul> <li>stage1:</li> <li><code>CREATE SEQUENCE &lt;tablename&gt;_&lt;colname&gt;_seq AS bigint START &lt;value&gt;</code>   (start value must be greater than number of rows in the table).</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; bigint DEFAULT 0,     ALTER COLUMN &lt;colname&gt; SET DEFAULT nextval('&lt;tablename&gt;_&lt;colname&gt;_seq').</code></li> <li><code>ALTER SEQUENCE &lt;tablename&gt;_&lt;colname&gt;_seq OWNED BY &lt;tablename&gt;.&lt;colname&gt;.</code></li> <li>stage2: Backfill the new column with values 1 .. N.</li> <li>stage3: Update the code to use the new column.</li> <li>stage4: Add a primary key constraint:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code> (from PostgreSQL 12, \u201cif a valid CHECK constraint is found   which proves no NULL can exist, then the table scan is skipped\u201d).</li> <li><code>CREATE UNIQUE INDEX CONCURRENTLY &lt;iname&gt; ON &lt;tablename&gt; ....</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;tablename&gt;_pkey PRIMARY KEY     USING INDEX &lt;iname&gt;.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;.</code></li> </ul>","text":""},{"location":"classification/#add-column-uuid-primary-key","title":"ADD COLUMN ... UUID PRIMARY KEY <p>Backward-incompatible migration requiring data backfilling</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; UUID.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt;     SET DEFAULT gen_random_uuid()</code> (for PostgreSQL &lt; 13, use uuid_generate_v4 function   from uuid-ossp extension).</li> <li>Update the code to use the new field.</li> <li>stage2: Backfill the new column with unique UUID values.</li> <li>stage4: Add primary key constraint:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code> (from PostgreSQL 12, \u201cif a valid CHECK constraint is found   which proves no NULL can exist, then the table scan is skipped\u201d).</li> <li><code>CREATE UNIQUE INDEX CONCURRENTLY &lt;iname&gt; ON &lt;tablename&gt; ....</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;tablename&gt;_pkey     PRIMARY KEY USING INDEX &lt;iname&gt;.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP DEFAULT.</code></li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;.</code></li> </ul>","text":""},{"location":"classification/#add-column-unique","title":"ADD COLUMN ... UNIQUE <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; ....</code></li> <li><code>CREATE UNIQUE INDEX CONCURRENTLY &lt;iname&gt; ON &lt;tablename&gt; ....</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt; UNIQUE USING INDEX &lt;iname&gt;.</code></li> </ul>","text":""},{"location":"classification/#add-column-generated-as-identity","title":"ADD COLUMN ... GENERATED AS IDENTITY <p>This operation going to acquire AccessExclusiveLock and rewrite the whole table on the spot. So the only safe way to do it is backward-incompatible migration requiring data backfilling.</p> <ul> <li>stage1:</li> <li><code>CREATE SEQUENCE &lt;tablename&gt;_&lt;colname&gt;_seq AS bigint START &lt;value&gt;</code><ul> <li>Note that start value shouldn't be 1, you need a space to backfill ids.</li> </ul> </li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN &lt;colname&gt; bigint DEFAULT 0,     ALTER COLUMN &lt;colname&gt; SET DEFAULT nextval('&lt;tablename&gt;_&lt;colname&gt;_seq').</code></li> <li><code>ALTER SEQUENCE &lt;tablename&gt;_&lt;colname&gt;_seq OWNED BY &lt;tablename&gt;.&lt;colname&gt;.</code></li> <li>stage2: Backfill the new column with unique sequential values.</li> <li>stage3:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID</code></li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code></li> <li><code>BEGIN</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP DEFAULT</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; ADD GENERATED BY DEFAULT     AS IDENTITY (START &lt;max_value&gt;)</code></li> <li><code>COMMIT</code></li> <li><code>DROP SEQUENCE &lt;tablename&gt;_&lt;colname&gt;_seq</code></li> </ul> <p>Be aware that IDENTITY doesn't guarantee that column is unique, if you want this, take a look on the \"Add UNIQUE Constraint\" section.</p>","text":""},{"location":"classification/#change-column-type","title":"Change Column Type <p>Here we have two cases:</p> <ul> <li>Backward-compatible migration \u2014 directly use <code>ALTER TABLE &lt;tablename&gt;   ALTER COLUMN &lt;colname&gt; TYPE ...</code> and update code in the following cases   (for PostgreSQL &gt;= 9.2):</li> <li>varchar(LESS) to varchar(MORE) where LESS &lt; MORE</li> <li>varchar(ANY) to text</li> <li>numeric(LESS, SAME) to numeric(MORE, SAME)   where LESS &lt; MORE and SAME == SAME</li> </ul> <p>Backward-incompatible migration requiring data backfilling in all other cases   (Tip: It's better to avoid such cases if possible):</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN new_&lt;colname&gt; ...</code>   (if column is NOT NULL, add this constraint in a separate migration;   see ALTER COLUMN ... SET NOT NULL).</li> <li>Dual write to both columns with a BEFORE INSERT/UPDATE trigger:</li> </ul> <pre><code>CREATE OR REPLACE FUNCTION &lt;fname&gt;()\n  RETURNS trigger\nAS\n$$\nBEGIN\n  NEW.&lt;new_colname&gt; := NEW.&lt;colname&gt;;\n  RETURN NEW;\nEND\n$$\nLANGUAGE 'plpgsql';\n\nCREATE TRIGGER &lt;tname&gt;\n  BEFORE INSERT OR UPDATE\n  ON &lt;tablename&gt;\n  FOR EACH ROW\n  EXECUTE PROCEDURE &lt;fname&gt;();\n</code></pre> <ul> <li>stage2: Backfill the new column with a copy of the old column\u2019s values.</li> <li>stage4:</li> <li>Add foreign key constraints referencing the new column   (see Add foreign key).</li> <li>Drop foreign key constraints referencing the old column   (see Drop foreign key).</li> <li>Rename  to old_ and new_ to    within a single transaction and explicit LOCK  statement. <li><code>DROP TRIGGER &lt;tname&gt;</code> in the same transaction.</li> <li><code>DROP FUNCTION &lt;fname&gt;</code> in the same transaction.</li> <li><code>DROP INDEX CONCURRENTLY</code> for all indexes using the old column.</li> <li><code>DROP COLUMN old_&lt;colname&gt;</code>.</li>","text":""},{"location":"classification/#rename-column","title":"Rename Column <p>Tip: Avoid renaming columns when possible.</p> <p>Backward-incompatible migration requiring data backfilling</p> <ul> <li>stage1:</li> <li>Rename the table and create a view for backward compatibility   (AccessExclusiveLock).</li> <li>Update code to use the new column.</li> </ul> <pre><code>BEGIN;\n\nALTER TABLE &lt;tablename&gt;\n  RENAME COLUMN &lt;colname&gt; TO &lt;new_colname&gt;;\n\nALTER TABLE &lt;tablename&gt; RENAME TO &lt;tablename&gt;_tmp;\n\nCREATE VIEW &lt;tablename&gt; AS\n  SELECT *, &lt;new_colname&gt; AS &lt;colname&gt;\n  FROM &lt;tablename&gt;_tmp;\n\nCOMMIT;\n</code></pre> <ul> <li>stage4: Drop the view and restore the original table name   (AccessExclusiveLock).</li> </ul> <pre><code>BEGIN;\n\nDROP VIEW &lt;tablename&gt;;\n\nALTER TABLE &lt;tablename&gt;_new RENAME TO &lt;tablename&gt;;\n\nCOMMIT;\n</code></pre> <p>DEPRECATED Approach:</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD COLUMN new_&lt;colname&gt; ...</code>   (if column is NOT NULL, add this constraint in a separate migration;   see ALTER COLUMN ... SET NOT NULL).</li> <li>Dual write to both columns with a BEFORE INSERT/UPDATE trigger:</li> </ul> <pre><code>CREATE OR REPLACE FUNCTION &lt;fname&gt;()\n  RETURNS trigger\nAS\n$$\nBEGIN\n  NEW.&lt;new_colname&gt; := NEW.&lt;colname&gt;;\n  RETURN NEW;\nEND\n$$\nLANGUAGE 'plpgsql';\n\nCREATE TRIGGER &lt;tname&gt;\n  BEFORE INSERT OR UPDATE\n  ON &lt;tablename&gt;\n  FOR EACH ROW\n  EXECUTE PROCEDURE &lt;fname&gt;();\n</code></pre> <ul> <li>stage2: Backfill the new column with a copy of the old column\u2019s values.</li> <li>stage3: Update code to use the new column name.</li> <li>stage4:</li> <li>Add foreign key constraints referencing the new column   (see Add foreign key).</li> <li>Drop foreign key constraints referencing the old column   (see Drop foreign key).</li> <li><code>DROP TRIGGER &lt;tname&gt;</code>.</li> <li><code>DROP FUNCTION &lt;fname&gt;</code>.</li> <li><code>DROP INDEX CONCURRENTLY</code> for all indexes using the old column.</li> <li><code>DROP COLUMN &lt;colname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#drop-column","title":"Drop Column <p>Backward-incompatible migration</p> <ul> <li>stage3: Update code to not use the column that will be dropped.</li> <li>stage4:</li> <li>Drop foreign key constraints referencing the column (see Drop foreign key).</li> <li><code>DROP INDEX CONCURRENTLY</code> for all indexes using the column.</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP COLUMN &lt;colname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#constraints","title":"Constraints","text":""},{"location":"classification/#add-not-null-constraint","title":"Add NOT NULL Constraint <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt;     CHECK (&lt;colname&gt; IS NOT NULL) NOT VALID</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;</code>   (may fail if data is inconsistent).</li> <li><code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; SET NOT NULL</code>   (from PostgreSQL 12, \u201cif a valid CHECK constraint is found   which proves no NULL can exist, then the table scan is skipped\u201d).</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#remove-not-null-constraint","title":"Remove NOT NULL Constraint <p>Backward-compatible migration</p> <ul> <li>stage1: <code>ALTER TABLE &lt;tablename&gt; ALTER COLUMN &lt;colname&gt; DROP NOT NULL</code>.</li> </ul>","text":""},{"location":"classification/#add-foreign-key","title":"Add Foreign Key <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD FOREIGN KEY ... NOT VALID</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;</code>   (may fail if data is inconsistent).</li> </ul>","text":""},{"location":"classification/#drop-foreign-key","title":"Drop Foreign Key <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#drop-primary-key-constraint","title":"Drop Primary Key Constraint <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li>Update code to not rely on the column</li> <li><code>DROP INDEX CONCURRENTLY</code> for all indexes</li> <li>Drop foreign keys in other tables</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#add-check-constraints","title":"Add Check Constraints <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt; CHECK (...) NOT VALID</code>.</li> <li><code>ALTER TABLE &lt;tablename&gt; VALIDATE CONSTRAINT &lt;cname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#drop-check-constraint","title":"Drop Check Constraint <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#add-unique-constraint","title":"Add UNIQUE Constraint <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>CREATE UNIQUE INDEX CONCURRENTLY &lt;iname&gt; ON &lt;tablename&gt; ....</code></li> <li><code>ALTER TABLE &lt;tablename&gt; ADD CONSTRAINT &lt;cname&gt; UNIQUE USING INDEX &lt;iname&gt;</code>.</li> </ul>","text":""},{"location":"classification/#drop-unique-constraint","title":"Drop UNIQUE Constraint <p>Backward-compatible migration</p> <ul> <li>stage1:</li> <li><code>DROP INDEX CONCURRENTLY</code></li> <li><code>SET lock_timeout = '1s';</code></li> <li><code>ALTER TABLE &lt;tablename&gt; DROP CONSTRAINT IF EXISTS &lt;cname&gt;.</code></li> </ul>","text":""},{"location":"classification/#data-migrations","title":"Data Migrations","text":"<p>All data migrations operations are lock-safe, but should be done with batches and considering database load.</p>"},{"location":"classification/#useful-links","title":"Useful Links","text":"<ul> <li>tbicr/django-pg-zero-downtime-migrations</li> <li>PostgreSQL at Scale: Database Schema Changes Without Downtime</li> <li>Waiting for PostgreSQL 11 \u2013 Fast ALTER TABLE ADD COLUMN with a non-NULL default</li> </ul>"},{"location":"rules/","title":"Rules API","text":"<p>Linter supports own format for declarative rules definition:</p> <pre><code>from migration_lint.sql.model import ConditionalMatch, KeywordLocator, SegmentLocator\n\nrule = SegmentLocator(\n    type=\"alter_table_statement\",\n    children=[\n        KeywordLocator(raw=\"ADD\"),\n        KeywordLocator(raw=\"CONSTRAINT\"),\n        KeywordLocator(raw=\"NOT\", inverted=True),\n        KeywordLocator(raw=\"VALID\", inverted=True),\n    ],\n    only_with=ConditionalMatch(\n        locator=SegmentLocator(type=\"create_table_statement\"),\n        match_by=SegmentLocator(type=\"table_reference\"),\n    ),\n)\n</code></pre> <ul> <li>SegmentLocator - definition for any SQL part.   It can match SQL code segments by a type   (see sqlfluff dialects and segment types),   raw content, children, etc.</li> <li>KeywordLocator - a short version of SegmentLocator   if you want to match the exact keyword.</li> <li>inverted=true - flag for children inverted matching,   for example in the example above it's   \"find ALTER TABLE ... ADD CONSTRAINT statement, but without NOT VALID\".</li> <li>ConditionalMatch - helps to check the migration context.   For example, the ADD FOREIGN KEY statement can be highly dangerous   if you run it on a big table, but if you just created this table,   it's totally fine. locator parameter helps to find statements in the same migration,   match_by helps to match the found statement with the one that is being checked.   In the example above it's \"find in the same migration CREATE TABLE statement   and ensure that it's the same table\".</li> </ul>"},{"location":"rules/#rules-order","title":"Rules order","text":"<p>Rules are being checked from safest to the most dangerous:</p> <ul> <li>Ignored</li> <li>Data migration</li> <li>Backward compatible</li> <li>Backward incompatible</li> <li>Restricted</li> </ul> <p>When you define a backward compatible, make sure that the rule is as specific as possible so that everything that is not explicitly allowed would be prohibited.</p>"},{"location":"rules/#ignoring-statements","title":"Ignoring statements","text":"<p>Add the following line in the migration SQL representation to ignore whole migration:</p> <pre><code>-- migration-lint: ignore\n</code></pre> <p>If you're using code-based migrations, make sure that the comment will appear in the SQL:</p> <pre><code># example for Alembic\nop.execute(\"SELECT 1; -- migration-lint: ignore\")\n\n# example for Django\nmigrations.RunSQL(\"SELECT 1; -- migration-lint: ignore\", migrations.RunSQL.noop),\n</code></pre>"},{"location":"tags/","title":"Tags","text":""}]}